Цель именованных кортежей — решить эти две проблемы.

Прежде всего, именованные кортежи являются неизменяемыми подобно обычным кортежам. Вы не можете изменять их после того, как вы что-то поместили в них.

Кроме этого, именованные кортежи это, эм..., _именованные кортежи_. Каждый объект сохраненный в них может быть доступен через уникальный, удобный для чтения человеком, идентификатор. Это освобождает вас от запоминания целочисленных индексов или выдумывания обходных путей типа определения целочисленных констант как мнемоник для ваших индексов.

Вот как выглядит именованный кортеж:

```
>>> from collections import namedtuple>>> Car = namedtuple('Car' , 'color mileage')
```

  

Чтобы использовать именованный кортеж, вам нужно импортировать модуль `collections`. Именованные кортежи были добавлены в стандартную библиотеку в Python 2.6. В примере выше мы определили простой тип данных "Car" с двумя полями: "color" и "mileage".

Вы можете найти синтаксис немного странным здесь. Почему мы передаём поля как строку закодированную с "color mileage"?

Ответ в том, что функция фабрики именованных кортежей вызывает метод `split()` на строки с именами полей. 
Таким образом, это, действительно, просто сокращение, чтобы сказать следующее:

```
>>> 'color mileage'.split()['color', 'mileage']>>> Car = namedtuple('Car', ['color', 'mileage'])
```


Конечно, вы также можете передать список со строками имён полей напрямую, если вы предпочитаете такой стиль.
Преимущество использования списка в том, что в этом случае легко переформатировать этот код, если вам понадобится разделить его на несколько линий:

```
>>> Car = namedtuple('Car', [
		'color',
		'mileage',
	])
	
>>> Car = namedtuple('Car', (
		'color',
		'mileage',
    ))
```


Как бы вы ни решили, сейчас вы можете создать новые объекты "car" через фабричную функцию `Car`. Поведение будет такое же, как если бы вы решили определить класс `Car` вручную и дать ему конструктор принимающий значения "color" и "mileage":

```
>>> my_car = Car('red', 3812.4)
>>> my_car.color
'red'
>>> my_car.mileage
3812.4
```

  

Распаковка кортежей и [оператор `*` для распаковки аргументов функций](https://www.youtube.com/watch?v=YWY4BZi_o28) также работают как ожидается:

```
>>> color, mileage = my_car
>>> print(color, mileage)
red 3812.4
>>> print(*my_car)
red 3812.4
```

  

Несмотря на доступ к значениям сохранённым в именованном кортеже через их идентификатор, вы всё ещё можете обращаться к ним через их индекс. Это свойство именованных кортежей может быть использовано для их распаковки в обычный кортеж:

```
>>> my_car[0]
'red'
>>> tuple(my_car)
('red', 3812.4)
```

  

Вы даже можете получить красивое строковое отображение объектов бесплатно, что сэкономит вам время и спасёт от избыточности:

```
>>> print(my_car)
Car(color='red' , mileage=3812.4)
```

  

Именованные кортежи, как и обычные кортежи, являются неизменяемыми. Когда вы попытаетесь перезаписать одно из их полей, вы получите исключение `AttributeError`:

```
>>> my_car.color = 'blue'
AttributeError: "can't set attribute"
```

  

Объекты именованных кортежей внутренне реализуются в питоне как обычные классы. Когда дело доходит до использованию памяти, то они так же "лучше", чем обычные классы и просто так же эффективны в использовании памяти как и обычные кортежи.


Хороший путь судить о них — считать, что именованные кортежи являются краткой формой для создания вручную эффективно работающего с памятью неизменяемого класса.